#pragma config(UART_Usage, UART1, uartUserControl, baudRate9600, IOPins, None, None)
#pragma config(Sensor, in1,    launchPot,      sensorPotentiometer)
#pragma config(Sensor, in2,    gyroXY,         sensorAnalog)
#pragma config(Sensor, in3,    Battery,        sensorAnalog)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  solenoid1,      sensorDigitalOut)
#pragma config(Sensor, dgtl6,  solenoid2,      sensorDigitalOut)
#pragma config(Sensor, dgtl7,  Ultra,          sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  liftLimitLow,   sensorDigitalIn)
#pragma config(Sensor, dgtl10, liftLimitHigh,  sensorDigitalIn)
#pragma config(Sensor, dgtl11, autonSelector,  sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  liftEncoder,    sensorNone)
#pragma config(Motor,  port1,           driveRightB,   tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,           liftMidLeft,   tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, None)
#pragma config(Motor,  port3,           driveRightM,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           liftBotRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           liftBotLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftTopLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftTopRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveLeftM,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           liftMidRight,  tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, None)
#pragma config(Motor,  port10,          driveLeftB,    tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma autonomousDuration(0)
#pragma userControlDuration(0)


//Large include file, handling function
//prototypes and including the seperate
//libraries based on the macros above
//Using a set of preprocessors, you
//can set the code to have multiple
//configurations, including choosing between
//different versions of the LCD Menu, and
//overall code archetypes for "Debugging,"
//"Competition," and for "RECORD_ONLY."


#include "Lib.c"


bool autonRunning = false;
//Boolean to state the autonomous
//is running or not

void pre_auton()
{

#ifdef __LCD_Lib__
	startTask(LCDMenu);
#endif

	initializeSensors();

	//Initialize the Gyro and start the LCD
	//Menu during the preautonomous time

}

task autonomous()
{
	if(!bResetFromWatchdogTimeout)
	{
		autonRunning = true;
		autoCode(autoValue);
		//Choose the autonomous based on
		//the global that can be reset and changed
		//via the LCD Library
		autonRunning = false;
	}
}


task usercontrol()
{
	PID l;

//	pidInit(&l,.1,0.0001,0,1000,5,127);
pidInit(&l,.15,0.0004,0.05,120,5,127);
	//PID Preset for hitting stars off the fence
	int liftVal = 400;

	clearSensors();
	clearDebugStream();


#ifdef __LCD_Lib__
#ifdef DEBUG
	//If we are debugging, we can use
	//the LCD Menu during driver mode.
	//Otherwise, we really shouldn't
	startTask(LCDMenu);
#endif
#endif

	bool _1200CisAwesome_ = true;

	bool btn8UPressed = false;
	bool btn5DPressed = false;
	bool btn5UPressed = false;
	bool btn6UPressed = false;
	bool btn7DPressed = false;
	//Variables to state whether or not
	//the buttons are currently being pushed.
	//Basically functions as a while(button);
	//while allowing other peices of code to run

	bool clawBool = true;


	startTask(LCDMenu);

	bool lPID  = false;

	bLCDBacklight = true;
	//	SensorValue[clawEncoder] = 0;
	while (_1200CisAwesome_)
	{
		if(abs(vexRT[Ch3]) < 15 && !lPID)
		{
			lPID = true;
			liftVal = SensorValue[launchPot];
		}

		else if(abs(vexRT[Ch3]) > 20)
		{
			lPID = false;
		}

		if(SensorValue[launchPot] > 2150)
		{
			lPID = false;
		}


		if(!vexRT[Btn5D])btn5DPressed = false;
		if(!vexRT[Btn5U])btn5UPressed = false;
		if(!vexRT[Btn6U])btn6UPressed = false;
		if(!vexRT[Btn8U])btn8UPressed = false;
		if(!vexRT[Btn7D])btn7DPressed = false;

		pidOut(&l, liftVal, SensorValue[launchPot]);
		//Constantly calculate PID Speeds

		/*----------------------------Non BitMapped Drive Code--------------------------*/

		if(vexRT[Btn5U] && !btn5UPressed)
		{
			btn5UPressed = true;
			if(clawBool) clawBool = false;
			else clawBool = true;
		}
		//Set claw bool in case we switch back
		//to pneumatics, and keep the logic and
		//switch the variable names if we use the
		//pneumatics for something else
		int chY = vexRT[Ch2];
		int chX = vexRT[Ch1];

		if(abs(chY) < 15) chY = 0;
		if(abs(chX) < 15) chX = 0;

		int leftSpeed = chY + chX;
		int rightSpeed = chY - chX;
		int liftSpeed = 0;

		if(!lPID)
		{
			liftSpeed = vexRT[Ch3];
		}
		else if(lPID)
		{
			liftSpeed = l.speed;
		}
		//Set Drive and Lift Speeds


		liftSpeed = vexRT[Ch3];

		SensorValue[solenoid1] = clawBool;
		SensorValue[solenoid2] = clawBool;
		//Setting Pneumatics, in case we
		//switch back to them


		chassisDrive(leftSpeed, rightSpeed);

		liftDrive(liftSpeed);

		//When the toggle is on, go to
		//the potentiometer value set previously

		//Run the Claw, Drive, and Lift Motors

		wait1Msec(1);
		//Don't hog the CPU
		//Wait time is built into Recorder
		//so don't wait when that is being run




		/*----------------------------Non Convoluted Drive Code--------------------------*/

	}
}
